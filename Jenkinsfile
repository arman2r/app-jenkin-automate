pipeline {
    agent any

    environment {
        APP_NAME = 'my-app-nextjs'
        APP_PORT = '3000'
        N8N_WEBHOOK = 'http://192.168.1.10:5678/webhook/jenkins-events' 
    }

    triggers {
        pollSCM('H/5 * * * *')
    }

    stages {
        stage('Inicio & Checkout') {
            steps {
                script {
                    // [RE-ACTIVACI√ìN] Reintroducimos la carga de la herramienta NodeJS para corregir "npm: not found".
                    // **Aseg√∫rate que el nombre 'NodeJS 22.x' COINCIDA EXACTAMENTE con tu configuraci√≥n en Manage Jenkins > Tools.**
                    try {
                        def nodeHome = tool name: 'NodeJS 22.x', type: 'jenkins.plugins.nodejs.tools.NodeJSInstallation'
                        env.PATH = "${nodeHome}/bin:${env.PATH}"
                        echo "NodeJS configurado usando la herramienta: NodeJS 22.x"
                    } catch (e) {
                        echo "‚ö†Ô∏è Advertencia: No se pudo cargar la herramienta NodeJS. 'npm ci' podr√≠a fallar si Node no est√° en el PATH del agente."
                        // Continuamos sin la herramienta, el fallo de 'npm: not found' se producir√° en la siguiente etapa.
                    }

                    currentBuild.description = "Build #${env.BUILD_NUMBER} - Iniciado"
                }

                echo 'üöÄ Iniciando pipeline de deployment...'

                // Notificar inicio - Usamos catchError para ignorar fallos de red.
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    sh """
                        curl -s -X POST -H "Content-Type: application/json" \
                        -d '{
                            "status": "started",
                            "job": "${env.JOB_NAME}",
                            "build": "${env.BUILD_NUMBER}",
                            "timestamp":"${new Date().format('yyyy-MM-dd HH:mm:ss')}",
                            "message": "üöÄ Build iniciado por Jenkins"
                        }' ${N8N_WEBHOOK}
                    """
                }

                echo 'üì¶ Clonando repositorio...'
                checkout scm // Checkout expl√≠cito

                script {
                    def gitCommit = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
                    def gitAuthor = sh(returnStdout: true, script: 'git log -1 --pretty=format:%an').trim()
                    def gitMessage = sh(returnStdout: true, script: 'git log -1 --pretty=format:%s').trim()

                    echo "üë§ Autor: ${gitAuthor}"
                    echo "üìù Commit: ${gitCommit}"
                    echo "üí¨ Mensaje: ${gitMessage}"

                    currentBuild.description = "${gitMessage} (${gitCommit})"
                }
            }
        }

        stage('Install Dependencies') {
            steps {
                echo 'üì• Instalando dependencias...'
                sh 'npm ci'
            }
        }

        stage('Build') {
            steps {
                echo 'üî® Construyendo aplicaci√≥n Next.js...'
                sh 'npm run build'

                // Notificar progreso - Usamos catchError para ignorar fallos de red.
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    sh """
                        curl -s -X POST -H "Content-Type: application/json" \
                        -d '{
                            "status": "progress",
                            "job": "${env.JOB_NAME}",
                            "build": "${env.BUILD_NUMBER}",
                            "message": "‚öôÔ∏è Build completado. Iniciando despliegue..."
                        }' ${N8N_WEBHOOK}
                    """
                }
            }
        }

        stage('Deploy') {
            steps {
                echo 'üöÄ Desplegando aplicaci√≥n...'
                script {
                    sh '''
                        # Matar proceso anterior si existe
                        if [ -f /var/jenkins_home/workspace/vision-fe/app.pid ]; then
                            PID=$(cat /var/jenkins_home/workspace/vision-fe/app.pid)
                            kill -9 $PID || true
                            rm /var/jenkins_home/workspace/vision-fe/app.pid
                        fi
                        
                        # Iniciar nueva aplicaci√≥n
                        # NOTA: Aseg√∫rate que el directorio de trabajo tenga los archivos de build de Next.js
                        nohup npm run start > /var/jenkins_home/workspace/vision-fe/app.log 2>&1 &
                        echo $! > /var/jenkins_home/workspace/vision-fe/app.pid
                        echo "Aplicaci√≥n iniciada con PID: $(cat /var/jenkins_home/workspace/vision-fe/app.pid)"
                    '''
                    sleep(time: 10, unit: 'SECONDS')
                    echo '‚úÖ Aplicaci√≥n desplegada en http://localhost:3000'
                }
            }
        }

        stage('Health Check') {
            steps {
                echo '‚ù§Ô∏è Verificando salud de la aplicaci√≥n...'
                script {
                    retry(3) {
                        sleep(time: 2, unit: 'SECONDS')
                        // Usamos un timeout m√°s corto y un '|| exit 1' para forzar el fallo si no responde
                        sh 'curl --connect-timeout 5 -f http://localhost:3000 || exit 1' 
                        echo '‚úÖ Aplicaci√≥n respondiendo correctamente'
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                def duration = currentBuild.durationString.replace(' and counting', '')
                echo '========================================='
                echo '‚úÖ DEPLOYMENT EXITOSO'
                echo '========================================='
                echo "‚è±Ô∏è ¬†Duraci√≥n: ${duration}"
                echo "üî¢ Build: #${env.BUILD_NUMBER}"
                echo "üåê URL: http://localhost:3000"
                echo "üìÖ ${new Date().format('dd/MM/yyyy HH:mm:ss')}"
                echo '========================================='

                // Notificar √©xito - Usamos catchError para ignorar fallos de red.
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    sh """
                        curl -s -X POST -H "Content-Type: application/json" \
                        -d '{
                            "status": "success",
                            "job": "${env.JOB_NAME}",
                            "build": "${env.BUILD_NUMBER}",
                            "message": "‚úÖ Build #${env.BUILD_NUMBER} completado correctamente en ${duration}"
                        }' ${N8N_WEBHOOK}
                    """
                }
            }
        }

        failure {
            script {
                echo '========================================='
                echo '‚ùå DEPLOYMENT FALLIDO'
                echo '========================================='
                echo "üî¢ Build: #${env.BUILD_NUMBER}"
                echo "üìÖ ${new Date().format('dd/MM/yyyy HH:mm:ss')}"
                echo '========================================='
                
                def failureMessage = "‚ùå Build fallido en Jenkins. Etapa de fallo: ${currentBuild.result}"

                // Notificar fallo - Usamos catchError para ignorar fallos de red.
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    sh """
                        curl -s -X POST -H "Content-Type: application/json" \
                        -d '{
                            "status": "failed",
                            "job": "${env.JOB_NAME}",
                            "build": "${env.BUILD_NUMBER}",
                            "message": "${failureMessage}",
                            "log": "Revisar la consola de Jenkins para m√°s detalles."
                        }' ${N8N_WEBHOOK}
                    """
                }
            }
        }

        always {
            echo 'üèÅ Pipeline finalizado'
            echo "Estado final: ${currentBuild.result}"
        }
    }
}
